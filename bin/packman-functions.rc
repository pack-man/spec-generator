set -o errtrace 
if [ ! -r /etc/packman/packman.rc ];then
        echo "Missing /etc/packman/packman.rc. Something is wrong with your ENV. Exiting."
        exit 1
fi
. /etc/packman/packman.rc
# required functions

validate_target_envs()
{
	SUPPORTED_ENVS="$1"
	unset UNSUPPORTED_ENVS
	OIFS=$IFS
	IFS=','
	for DA_ENV in $SUPPORTED_ENVS;do
		if [ ! -d /etc/packman/docker-specs/$DA_ENV ];then
			UNSUPPORTED_ENVS="$UNSUPPORTED_ENVS $DA_ENV"
	   	fi
	done

	IFS=$OIFS
	if [ -n "$UNSUPPORTED_ENVS" ];then
		export UNSUPPORTED_ENVS
		return 1
	fi
}

validate_url()
{
	SOURCE_URL=$1
	curl -f "$SOURCE_URL" -k  > /dev/null 2>&1
        return $?

}
launch_containers_for_target_envs()
{
	TARGET_ENVS="$1"
	PACKAGE_RC="$2"
	OIFS=$IFS
	IFS=','
	for DA_ENV in $TARGET_ENVS;do
		start_docker_container "/etc/packman/docker-specs/$DA_ENV" $PACKAGE_RC
	done

	IFS=$OIFS
}

start_docker_container()
{
	DOCKER_DIR=$1
	PACKAGE_RC=$2
	. $PACKAGE_RC
	IMAGE_NAME=`basename $DOCKER_DIR`
	sudo docker build --no-cache -t $IMAGE_NAME-$PACKAGE_NAME "$DOCKER_DIR" 
	sudo docker run -t $IMAGE_NAME-$PACKAGE_NAME mkdir -p /etc/packman 
	CONTAINER_ID=`get_container_id $IMAGE_NAME-$PACKAGE_NAME`
	sudo docker commit $CONTAINER_ID $IMAGE_NAME-$PACKAGE_NAME
	sudo docker run -t $IMAGE_NAME-$PACKAGE_NAME  mkdir -p $PACKMAN_HOME/.ssh
	CONTAINER_ID=`get_container_id $IMAGE_NAME-$PACKAGE_NAME`
	sudo docker commit $CONTAINER_ID $IMAGE_NAME-$PACKAGE_NAME
	sudo docker cp $PACKMAN_PRIVATE_KEY  $CONTAINER_ID:$PACKMAN_HOME/.ssh/id_rsa
	sudo docker commit $CONTAINER_ID $IMAGE_NAME-$PACKAGE_NAME
	sudo docker cp $PACKAGE_RC $CONTAINER_ID:/etc/packman/package.rc
	sudo docker commit $CONTAINER_ID $IMAGE_NAME-$PACKAGE_NAME

	sudo docker run -t $IMAGE_NAME-$PACKAGE_NAME chown -R packman.packman $PACKMAN_HOME
	CONTAINER_ID=`get_container_id $IMAGE_NAME-$PACKAGE_NAME`
	sudo docker commit $CONTAINER_ID $IMAGE_NAME-$PACKAGE_NAME

	sudo docker run -t $IMAGE_NAME-$PACKAGE_NAME su - packman -c "packman-prepare-build-env && packman-gen-spec /etc/packman/package.rc"
	CONTAINER_ID=`get_container_id $IMAGE_NAME-$PACKAGE_NAME`
	sudo docker commit $CONTAINER_ID $IMAGE_NAME-$PACKAGE_NAME-postrun
	# here we need to push the new container to docker.packdaddy.io
}

destroy_docker_container()
{
	IMAGE_NAME=$1
	sudo docker rmi $IMAGE_NAME
}

get_container_id()
{
	IMAGE_NAME=$1
	sudo docker ps -l|grep "$1"|awk -F " " '{print $1}'
}

replace_rpm_spec_tokens()
{
        PACKAGE_RC=$1
        SPEC_FILE=$2
        . $PACKAGE_RC
	PACKAGE_SUMMARY=`head -1 $PACKAGE_DESCRIPTION`
        sed "s#@@PACKAGE_SUMMARY@@#$PACKAGE_SUMMARY#g" -i $SPEC_FILE
        DESCRIPTION=`cat $PACKAGE_DESCRIPTION|sed ':a;N;$!ba;s/\n/\\\\\n/g'`
        sed "s#@@PACKAGE_DESCRIPTION@@#${DESCRIPTION}#g" -i $SPEC_FILE
        for VAR in `grep -v "^#" $PACKAGE_RC |awk -F "="  '{print $1}' |xargs`;do
                sed "s#@@$VAR@@#${!VAR}#g" -i $SPEC_FILE
        done
	
}

env_packaging_format()
{
	DISTRO=`lsb_release -i -s`
	if [ "$DISTRO" = "Ubuntu" -o "$DISTRO" = "Debian" ];then
		return $DEB 
	elif [ "$DISTRO" = "CentOS" ];then
		return $RPM
	fi
}

add_github_com_to_known_hosts()
{
	touch ~/.ssh/known_hosts
	ssh-keyscan github.com >> ~/.ssh/known_hosts
}

log()
{
	printf $1 
}

repo_registered()
{
	REPO_NAME=$1
	curl -X POST -sS -H 'X-API-ID: '$PACKMAN_API_ID'' -H 'X-API-PRIVATE-KEY: '$PACKMAN_API_KEY'' -H 'X-API-ROUTE: repos/list' -H 'Content-Type: application/json' $PACKMAN_API_ENDPOINT | jq '.[] | .uri' --raw-output|grep -q "^$REPO_NAME$" 

}

register_new_repo()
{
	REPO_NAME=$1
	REPO_URI=$2
	OUT=`curl -X POST -sS -H 'X-API-ID: '$PACKMAN_API_ID'' -H 'X-API-PRIVATE-KEY: '$PACKMAN_API_KEY'' -H 'X-API-ROUTE: repos/add' -H 'Content-Type: application/json' -d '{"name": "'"$REPO_NAME"'", "uri":"'"$REPO_URI"'"}' $PACKMAN_API_ENDPOINT` 
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
		return 1
	elif [ "$STATUS" = 'SUCCESS' ];then
		echo $OUT|jq '.id' --raw-output
	fi
}


create_ssh_key()
{
	KEY_PATH=$1
	ssh-keygen -t rsa -N "" -f $KEY_PATH
}

set_docker_ca_cert()
{
	mkdir /usr/local/share/ca-certificates/docker-dev-cert
	curl https://packdaddy.io/devdockerCA.crt > /usr/local/share/ca-certificates/docker-dev-cert/devdockerCA.crt
	update-ca-certificates
	
}

install_nodejs()
{
	env_packaging_format
	PACKAGE_FORMAT=$?
	if [ $PACKAGE_FORMAT -eq $RPM ];then
		RUN curl --silent --location https://rpm.nodesource.com/setup_4.x | bash - && yum -y install nodejs
	elif [ $PACKAGE_FORMAT -eq $DEB ];then
		RUN curl -sL https://deb.nodesource.com/setup_4.x | sudo -E bash - && aptitude install -y nodejs
	fi
}

# GitHub API
github_repo_exists()
{
	echo stub
}

create_github_repo()
{
	GITHUB_ORG=$1
	REPO_NAME=$2
	curl -X POST -H "Authorization: token $GITHUB_TOKEN"  --data '{"name":"'"$REPO_NAME"'","has_issues":"true","has_downloads":"true"}' https://api.github.com/orgs/$GITHUB_ORG/repos
}

add_github_repo_key()
{
	KEY_NAME=$1
	KEY_PATH=$2
	KEY=`cat $KEY_PATH`
	GITHUB_ORG=$3
	REPO_NAME=$4
	curl -X POST -sS  -H "Authorization: token $GITHUB_TOKEN" --data '{"title":"'"$KEY_NAME"'","key":"'"$KEY"'"}' https://api.github.com/repos/$GITHUB_ORG/$REPO_NAME/keys
}

github_repo_exists()
{
	echo stub
}

create_github_repo()
{
	GITHUB_ORG=$1
	REPO_NAME=$2
	curl -X POST -sS -H "Authorization: token $GITHUB_TOKEN"  --data '{"name":"'"$REPO_NAME"'","has_issues":"true","has_downloads":"true"}' https://api.github.com/orgs/$GITHUB_ORG/repos
}

add_github_repo_key()
{
	KEY_NAME=$1
	KEY_PATH=$2
	KEY=`cat $KEY_PATH`
	GITHUB_ORG=$3
	REPO_NAME=$4
	curl -X POST -sS -H "Authorization: token $GITHUB_TOKEN" --data '{"title":"'"$KEY_NAME"'","key":"'"$KEY"'"}' https://api.github.com/repos/$GITHUB_ORG/$REPO_NAME/keys
}


# packdaddy API

new_package_api()
{
	RC_FILE=$1
	. $RC_FILE
	PACK_DESCRIPTION=`cat $PACKAGE_DESCRIPTION`
	OUT=`curl -X POST -sS -H 'X-API-ID: '$PACKMAN_API_ID'' -H 'X-API-PRIVATE-KEY: '$PACKMAN_API_KEY'' -H 'X-API-ROUTE: packages/add' -H 'Content-Type: application/json'  -d '{"packman_space": "'"$PACKMAN_SPACE"'", "name": "'"$PACKAGE_NAME"'", "version": "'"$PACKAGE_VERSION"'", "source_url": "'"$SOURCE_URL"'", "project_url": "'"$PROJECT_URL"'", "description": "'"$PACK_DESCRIPTION"'", "maintainer_name": "'"$MAINTAINER_NAME"'","maintainer_email":"'"$MAINTAINER_EMAIL"'","repo_id": "'"$REPO_ID"'"}' $PACKMAN_API_ENDPOINT`
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
		return 1
	fi
}

new_job_api()
{
	PACKAGE_NAME=$1
	PACKAGE_VERSION=$2
	PACKMAN_SPACE=$3
	ENV=$4
}

update_job_api()
{
	JOB_ID=$1
	JOB_STATUS=$2
	OUT=`curl -X POST -sS -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: jobs/update/$JOB_ID" -H 'Content-Type: application/json' -d '{"status":"'"$JOB_STATUS"'"}' $PACKMAN_API_ENDPOINT`
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
	fi
}

new_event_api()
{
	EVENT_TYPE=$1
	JOB_ID=$2
	CONTENT=$3
	OUT=`curl -X POST -sS  -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: events/add" -H 'Content-Type: application/json' -d '{"event_type":"'"$EVENT_TYPE"'","job_id":"'"$JOB_ID"'","content":"'"$CONTENT"'"}' $PACKMAN_API_ENDPOINT`
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
	fi

	if [ "$EVENT_TYPE" -eq "$EVENT_FATAL" ];then
		COLOUR=$BRIGHT_RED
	elif [ "$EVENT_TYPE" -eq "$EVENT_WARNING" ];then
		COLOUR=$YELLOW
	elif [ "$EVENT_TYPE" -eq "$EVENT_AUTO_FIX" ];then
		COLOUR=$GREEN
	else
		COLOUR=$CYAN
	fi
	printf "${COLOUR}$CONTENT${NORMAL}\n"
}

new_job_api()
{
	PACKAGE_NAME=$1
	PACKAGE_VERSION=$2
	PACKMAN_SPACE=$3
	ENV=$4
}

update_job_api()
{
	JOB_ID=$1
	JOB_STATUS=$2
	OUT=`curl -X POST -sS  -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: jobs/update/$JOB_ID" -H 'Content-Type: application/json' -d '{"status":"'"$JOB_STATUS"'"}' $PACKMAN_API_ENDPOINT`
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
	fi
}

new_event_api()
{
	EVENT_TYPE=$1
	JOB_ID=$2
	CONTENT=$3
	OUT=`curl -X POST -sS  -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: events/add" -H 'Content-Type: application/json' -d '{"event_type":"'"$EVENT_TYPE"'","job_id":"'"$JOB_ID"'","content":"'"$CONTENT"'"}' $PACKMAN_API_ENDPOINT`
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
	fi
}

new_package_spec_api()
{
	PACKAGE_ID=$1
	PACKAGE_TYPE=$2
	SPEC_PATH=$3
	OUT=`curl -X POST -sS -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H 'X-API-ROUTE: packagespecs/add' -H 'Content-Type: application/json' -d '{"package_id": "'"$PACKAGE_ID"'","package_type":"'"$PACKAGE_TYPE"'", "spec_path":"'"$SPEC_PATH"'"}' $PACKMAN_API_ENDPOINT`
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
	fi
}

update_package_status_api()
{
	PACKAGE_ID=$1
	PACKAGE_STATUS=$2
	OUT=`curl -X POST -sS  -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: packages/update/$PACKAGE_ID" -H 'Content-Type: application/json' -d '{"status": "'"$PACKAGE_STATUS"'"}' $PACKMAN_API_ENDPOINT`
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
	fi
}

fatal_event_api()
{
	PACKAGE_ID=$1
	JOB_ID=$2
	MESSAGE=$3
	new_event_api $EVENT_FATAL $JOB_ID "$MESSAGE"
	update_package_status_api $PACKAGE_ID $PACKAGE_FAILED
}

get_package_type_build_env_api()
{
	PACKAGE_TYPE=$1
	OUT=`curl -X POST -sS  -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: packagebuildenv/list" -H 'Content-Type: application/json' -d '{"package_type": "'"$PACKAGE_TYPE"'"}' $PACKMAN_API_ENDPOINT`
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
	else
		echo $OUT| jq '.data[] | .build_env' --raw-output 
	fi
}

get_package_type_api()
{
	PACKAGE_ID=$1
	OUT=`curl -X POST -sS  -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: packagespecs/list" -H 'Content-Type: application/json' -d '{"package_id": "'"$PACKAGE_ID"'"}' $PACKMAN_API_ENDPOINT`

	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
	else
		echo $OUT| jq '.data[] | .package_type' --raw-output 
	fi
}

get_package_description_api()
{
	PACKAGE_ID=$1
	curl -X POST -sS  -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: packages/get/$PACKAGE_ID" -H 'Content-Type: application/json' -d '{}' $PACKMAN_API_ENDPOINT | jq  '.data[] | .description' --raw-output
}
add_package_dep_api()
{
	PACKAGE_ID=$1
	PACKAGE_TYPE=$2
	PACKAGE_ENV=$3
	DEP_TYPE=$4
	DEPENDS_ON_PACKAGE=$5
	NEEDED_FILES=$6
	
	curl -X POST -sS  -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: /packagedeps/add" -H 'Content-Type: application/json' -d '{"package_id":"'"$PACKAGE_ID"'", "package_type":"'"$PACKAGE_TYPE"'", "env":"'"$PACKAGE_ENV"'","dep_type":"'"$DEP_TYPE"'","depends_on_package":"'"$DEPENDS_ON_PACKAGE"'","needed_files":"'"$NEEDED_FILES"'"}' $PACKMAN_API_ENDPOINT

}
package_type_build_env_api()
{
	PACKAGE_TYPE=$1
	OUT=`curl -X POST -sS  -H "X-API-ID: $PACKMAN_API_ID" -H "X-API-PRIVATE-KEY: $PACKMAN_API_KEY" -H "X-API-ROUTE: packagebuildenv/list" -H 'Content-Type: application/json' -d '{"package_type": "'"$PACKAGE_TYPE"'"}' $PACKMAN_API_ENDPOINT`
	STATUS=`echo $OUT|jq .request_status --raw-output` 
	if [ "$STATUS" = 'ERROR' ];then
		echo $OUT|jq '.message' --raw-output
	else
		echo $OUT| jq '.[] | .build_env' --raw-output 
	fi
}


trap_handler()
{
        MYSELF=`basename "$0"`               # equals to my script name
        LASTLINE="$1"            # argument 1: last line of error occurence
        LASTERR="$2"             # argument 2: error code of last command
		
	new_event_api $EVENT_FATAL $JOB_ID "Returned with $LASTERR on $MYSELF:$LASTLINE"
	#update_job_api $JOB_ID $JOB_FATAL
}


# validate PACKAGE_NAME
# validate PACKAGE_VERSION
